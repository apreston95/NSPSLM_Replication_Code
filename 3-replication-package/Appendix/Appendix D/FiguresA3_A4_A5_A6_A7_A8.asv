clc
clear all
close all

KBAR = 80;

options = optimoptions('fsolve','Display','off','tolfun',1e-10,'tolx',1e-10);


Gamma = 2;
Beta = 0.99;
Rho = 0.044;
Sigma = 6;
Theta = 58.7;
Delta_Pi = 1.5;
Alpha = 0.65;
Lambda = 0.717;
Rho_A = 0.99;
Vacfrac = 0.01;
Delta_News = 0;



A_Bar = 1;
Pi_Bar = 0;
N_Bar = 0.955;
U_Bar = 1-N_Bar*(1-Rho);
M_Bar = Rho*N_Bar;
Eta_Bar = M_Bar/U_Bar;
V_Bar = (M_Bar/U_Bar^(Alpha))^(1/(1-Alpha));
Eta_V_Bar = M_Bar/V_Bar;
Y_Bar = A_Bar*N_Bar;
B = 0.065*Y_Bar;
MC_Bar = (Sigma-1)/Sigma;
Kappa = Vacfrac*(Y_Bar/V_Bar);
Wage = @(x) MC_Bar - (1/A_Bar)*(x + (Kappa/Eta_V_Bar) - Beta*(1-Rho)*(Kappa/Eta_V_Bar));
W_Bar = fsolve(Wage,1,options);
b_Bar = Lambda*W_Bar;
JC_Bar = 1 - Rho*(1-Eta_Bar);

Psi_E_vec = zeros(1,KBAR);
for j = 0:KBAR-2
  Psi_E_vec(j+1) = M_Bar*(JC_Bar)^(j);
end


Psi_E_vec(1,KBAR) = N_Bar - sum(Psi_E_vec(1,1:KBAR-1));


par.Gamma = Gamma;
par.Beta = Beta;
par.Rho = Rho;
par.Sigma = Sigma;
par.Theta = Theta;
par.Delta_Pi = Delta_Pi;
par.Alpha = Alpha;
par.Lambda = Lambda;
par.Rho_A = Rho_A;
par.Kappa = Kappa;

par.A_Bar = A_Bar;
par.Pi_Bar = Pi_Bar;
par.N_Bar = N_Bar;
par.U_Bar = U_Bar;
par.M_Bar = M_Bar;
par.Eta_Bar = Eta_Bar;
par.Y_Bar = Y_Bar;
par.B = B;
par.MC_Bar = MC_Bar;
par.V_Bar = V_Bar;
par.Eta_V_Bar = Eta_V_Bar;
par.W_Bar = W_Bar;
par.b_Bar = b_Bar;
par.JC_Bar = JC_Bar;
par.Delta_News = Delta_News;



save params par;

%% Diffusion News Shock (Figure A3)


dynare NSPSLM_Het_Diffusion noclearall nolog;


%% Nominal Rigidities (Figure A4)


dynare NSPSLM_Het_NomWageRigid noclearall nolog;

%% Endogenous Separations (Figure A5)

dynare NSPSLM_Het_Endogenous_Sep noclearall nolog;


%% Labour Supply (Figure A6)


dynare NSPSLM_Het_LabourSupply noclearall nolog;

%% Unemployment Benefit (Figure A7)

dynare NSPSLM_Het_UnempBenefit noclearall nolog;



%% Asymmetric IRFs (Figure A8)

clear all
close all

KBAR = 20;

options = optimoptions('fsolve','Display','off','tolfun',1e-10,'tolx',1e-10);


Gamma = 2;
Beta = 0.99;
Rho = 0.044;
Sigma = 6;
Theta = 58.7;
Delta_Pi = 1.5;
Alpha = 0.65;
Lambda = 0.717;
Rho_A = 0.99;
Vacfrac = 0.01;
Delta_News = 0;



A_Bar = 1;
Pi_Bar = 0;
N_Bar = 0.955;
U_Bar = 1-N_Bar*(1-Rho);
M_Bar = Rho*N_Bar;
Eta_Bar = M_Bar/U_Bar;
V_Bar = (M_Bar/U_Bar^(Alpha))^(1/(1-Alpha));
Eta_V_Bar = M_Bar/V_Bar;
Y_Bar = A_Bar*N_Bar;
B = 0.065*Y_Bar;
MC_Bar = (Sigma-1)/Sigma;
Kappa = Vacfrac*(Y_Bar/V_Bar);
Wage = @(x) MC_Bar - (1/A_Bar)*(x + (Kappa/Eta_V_Bar) - Beta*(1-Rho)*(Kappa/Eta_V_Bar));
W_Bar = fsolve(Wage,1,options);
b_Bar = Lambda*W_Bar;
JC_Bar = 1 - Rho*(1-Eta_Bar);

Psi_E_vec = zeros(1,KBAR);
for j = 0:KBAR-2
  Psi_E_vec(j+1) = M_Bar*(JC_Bar)^(j);
end


Psi_E_vec(1,KBAR) = N_Bar - sum(Psi_E_vec(1,1:KBAR-1));


par.Gamma = Gamma;
par.Beta = Beta;
par.Rho = Rho;
par.Sigma = Sigma;
par.Theta = Theta;
par.Delta_Pi = Delta_Pi;
par.Alpha = Alpha;
par.Lambda = Lambda;
par.Rho_A = Rho_A;
par.Kappa = Kappa;

par.A_Bar = A_Bar;
par.Pi_Bar = Pi_Bar;
par.N_Bar = N_Bar;
par.U_Bar = U_Bar;
par.M_Bar = M_Bar;
par.Eta_Bar = Eta_Bar;
par.Y_Bar = Y_Bar;
par.B = B;
par.MC_Bar = MC_Bar;
par.V_Bar = V_Bar;
par.Eta_V_Bar = Eta_V_Bar;
par.W_Bar = W_Bar;
par.b_Bar = b_Bar;
par.JC_Bar = JC_Bar;
par.Delta_News = Delta_News;



save params par;




% 1. Run Dynare model
dynare NSPSLM_Het_Asymmetry noclearall nolog;

% 2. Setup initial conditions and references
y0 = oo_.dr.ys;      % Steady state from Dynare's results
dr = oo_.dr;         % Decision rules
M = M_;              % Copy of the global M_ struct (often used for clarity)
opts = options_;     % Copy of the global options_ struct

% 3. Simulation parameters
IRF_length = 20;     % number of periods for IRFs
shock_size = 0.01;   % 1% shock

% 4. Identify shock
shock_var_name = 'Eps_A4'; % <--- replace with your shock?s name
shock_var_pos = strmatch(shock_var_name, M.exo_names, 'exact');
if isempty(shock_var_pos)
    error(['Shock variable ', shock_var_name, ' not found in M.exo_names!']);
end

% 5. Positive & Negative shock vectors (each exo_nbr x 1)
shock_pos = zeros(M.exo_nbr,1);
shock_neg = zeros(M.exo_nbr,1);
shock_pos(shock_var_pos) = +shock_size;
shock_neg(shock_var_pos) = -shock_size;

% 6. Construct T x exo_nbr shock matrices (T = IRF_length + 1)
ex_pos = [shock_pos'; zeros(IRF_length, M.exo_nbr)];
ex_neg = [shock_neg'; zeros(IRF_length, M.exo_nbr)];

% 7. CALL THE 6-ARGUMENT simult_ FUNCTION
%    "M_, options_, y0, dr, ex_, iorder"
y_sim_pos = simult_(M, opts, y0, dr, ex_pos, 3);
y_sim_neg = simult_(M, opts, y0, dr, ex_neg, 3);

% 8. Extract IRFs for the variable of interest
var_name = 'logY';  % <--- replace with the endogenous var you want
var_idx = strmatch(var_name, M.endo_names, 'exact');
if isempty(var_idx)
    error(['Endogenous variable ', var_name, ' not found in M.endo_names!']);
end

% Note: simult_ returns (n x (T+max_lag)). If max_lag=1, it?s n x (IRF_length+1+1).
% The first column is the state at time=1, etc. Often we treat the ?pre-shock?
% period as t=0. If needed, adjust indexing. Here, we simply keep the first IRF_length+1 columns.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% (Snippet) Period 0 = Shock Realization in the IRF Plots
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% 9. Build IRF series so that t=1 in simult_ becomes t=0 on the graph.
% We simply select the first (IRF_length + 1) columns.
IRF_pos = y_sim_pos(var_idx, 2:end);
IRF_neg = y_sim_neg(var_idx, 2:end);

% Now we have IRF_length+1 data points for each series, matching 0:IRF_length on X-axis
figure;
plot(0:IRF_length, 100.*(IRF_pos - y0(var_idx)), '-b', 'LineWidth', 2); 
hold on;
plot(0:IRF_length, 100.*(IRF_neg - y0(var_idx)), '--r', 'LineWidth', 2);
xlabel('Quarters after Shock', 'Interpreter', 'latex');
ylabel(['\% Deviation'], 'Interpreter', 'latex');
title(['Output'], 'Interpreter', 'latex');
legend('Positive shock','Negative shock', 'Interpreter','latex');
%grid on;
hold off;

print('FigureA8','-dpng');


% 10. (Optional) Check numerical asymmetry
%     If the model were fully linear or symmetrical in 3rd-order terms,
%     the sum of pos & neg deviations might be near zero.
IRF_asymmetry = (IRF_pos - y0(var_idx)) + (IRF_neg - y0(var_idx));
disp('Numerical asymmetry at each horizon (0 implies symmetry):');
disp(IRF_asymmetry');
